<!DOCTYPE html>
<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <title>Isometric Game</title>
  <style>
    body {
      margin:0px;
      padding:0px;
      text-align:center;
      background-color: #000;
    }

    canvas{
      outline:0;
      border:1px solid #666;
  	  image-rendering: optimizeSpeed;             /* Older versions of FF          */
  	  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
  	  image-rendering: -webkit-optimize-contrast; /* Safari                        */
  	  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
  	  image-rendering: pixelated;                 /* Awesome future-browsers       */
  	  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
  	  transform:scale(2);
  	  transform-origin: top;
      margin-left: auto;
      margin-right: auto;
      margin-top:40px;
    }
  </style>
</head>
<body>

<script src="js/Point.js" type="text/javascript"></script>
<script src="js/Level.js" type="text/javascript"></script>
<script src="js/WorldConstants.js" type="text/javascript"></script>
<script src="js/Coordinates.js" type="text/javascript"></script>
<script src="js/Viewport.js" type="text/javascript"></script>

<script src="js/Mouse.js" type="text/javascript"></script>

<script src="js/Player.js" type="text/javascript"></script>


<canvas id='c'></canvas>
<script>

var gLoop,
c = document.getElementById('c'),
ctx = c.getContext('2d');

c.width = Viewport.width;
c.height = Viewport.height;
var keysDown = {};
var keyHeldDown = 0;
var player = new Player();
Level.loadTileset();

addEventListener("keydown", function (e) {
	keysDown[e.keyCode] = true;
}, false);

addEventListener("keyup", function (e) {
	delete keysDown[e.keyCode];
}, false);

addEventListener('mousedown', function (e) {
  
  Mouse.isDown=true;
}, false);

addEventListener('mouseup', function (e) {
  Mouse.isDown=false;
  Mouse.click = 0;
}, false);

function getMousePos(canvas, evt){
    // get canvas position
    var obj = canvas;
    var top = 0;
    var left = 0;
    while (obj && obj.tagName != 'body') {
        top += obj.offsetTop;
        left += obj.offsetLeft;
        obj = obj.offsetParent;
    }

    // return relative mouse position
    Mouse.x = (evt.clientX - left + window.pageXOffset)/2 + 160;
    Mouse.y = (evt.clientY - top + window.pageYOffset)/2;

}

var canvas = document.getElementById('c');
canvas.addEventListener('mousemove', function(evt){
        getMousePos(canvas, evt);

}, false);

var frontier = [];
var cameFrom = new Map();
var goal = new Point(0,0);
var path = [];

var GameLoop = function(){
    if(Mouse.isDown) {
      Mouse.click++;
    }
    clearBlack();
    checkKeys();
   //   var frontier = [];
    var mp = Coordinates.getTileCoordinates(Coordinates.to2d(new Point(-Viewport.isoPos().x+Mouse.x, -Viewport.isoPos().y+Mouse.y)), Level.tileSize);
    if(Mouse.click===1 && Coordinates.inWorldBounds(mp)) {
      var isoMouse = Coordinates.to2d(new Point(Mouse.x,Mouse.y));
      goal = new Point(mp.x,mp.y);
        
      frontier = [];
      cameFrom = new Map();
      
      frontier.push(player.getLevelCoordinates());      
      cameFrom.set(player.getLevelCoordinates().x+player.getLevelCoordinates().y*Level.levelWidth, null);
     
      
      while(frontier.length > 0) {
        var current = frontier.shift();
        if(current.x === mp.x && current.y === mp.y) {
         
          break;
        }
        var neighbours = getNeighbours(current, cameFrom);
        for(var i=0; i < neighbours.length; i++) {
          if(!hasPoint(cameFrom,neighbours[i])) {
            frontier.push(neighbours[i]);
            cameFrom.set(neighbours[i].x + neighbours[i].y*Level.levelWidth, current);
          } 
        }
        
      }
      path = [];
      var c = goal;
      while(c && !(c.x === player.getLevelCoordinates().x && c.y === player.getLevelCoordinates().y)) {
        path.push(c);
        c = cameFrom.get(c.x + c.y*Level.levelWidth);
      }
      player.setPath(path);
      
    }
    player.moveTowardsGoal();
    Level.render(ctx, player, mp);
    
    
    
    if(WorldConstants.debugOutput) {
      for (var value of cameFrom.keys()) {
        if(value && cameFrom.get(value)) { 
          
        drawTile(new Point(cameFrom.get(value).x*Level.tileSize, cameFrom.get(value).y*Level.tileSize), Level.tileSize, Level.tileSize);
      }
      }
    }

    if(WorldConstants.debugOutput) {
        for(var i = 0; i < path.length;i++) {
          ctx.fillStyle = "#700";
          drawTile(new Point(path[i].x*Level.tileSize, path[i].y*Level.tileSize), Level.tileSize, Level.tileSize);
      }
    }
    //player.render(ctx);
    gLoop = setTimeout(GameLoop, 20);
    return;
}

var getNeighbours = function(p, cameFrom) {
  if(!Coordinates.inWorldBounds(p)) {
    return [];
  }
  var result = [];
    var n = new Point(p.x+1,p.y);
    if(isValidWalkingTile(n)) {
      result.push(n);
    }
    n = new Point(p.x-1,p.y);
    if(isValidWalkingTile(n)) {
      result.push(n);
    }
    n = new Point(p.x,p.y+1);
    if(isValidWalkingTile(n)) {
      result.push(n);
    }
    n = new Point(p.x,p.y-1);
    if(isValidWalkingTile(n)) {
      result.push(n);
    }
    // Diagonals
    n = new Point(p.x-1,p.y-1);
    if(isValidWalkingTile(n) && isValidDiagonal(n)) {
      result.push(n);
    }
    n = new Point(p.x+1,p.y-1);
    if(isValidWalkingTile(n) && isValidDiagonal(n)) {
      result.push(n);
    }
    n = new Point(p.x-1,p.y+1);
    if(isValidWalkingTile(n) && isValidDiagonal(n)) {
      result.push(n);
    }
    n = new Point(p.x-1,p.y-1);
    if(isValidWalkingTile(n) && isValidDiagonal(n)) {
      result.push(n);
    }
  return result;
}

var isValidWalkingTile = function(p) {
  return !cameFrom.get(p.x+p.y*Level.levelWidth) && Coordinates.inWorldBounds(p) && Level.currentLevel[p.x+p.y*Level.levelWidth]===0;
}

var isValidDiagonal = function(p) {
  return Level.currentLevel[p.x+1+p.y*Level.levelWidth]===0 &&
    Level.currentLevel[p.x-1+p.y*Level.levelWidth]===0 &&
    Level.currentLevel[p.x+(p.y+1)*Level.levelWidth]===0 &&
    Level.currentLevel[p.x+(p.y-1)*Level.levelWidth]===0;

}

var hasPoint = function(mapToSearch, p) {
  for (var value of mapToSearch.values()) {
    if(value && value.x === p.x && value.y === p.y) {
      return true;
    }
  }
  return false;
}

var clearBlack = function() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,640,300);
}

var drawTile = function(p,width,height) {
  ctx.beginPath();
  var newP = Coordinates.toIso(p);
  ctx.moveTo(Math.round(Viewport.isoPos().x + newP.x),Math.round(Viewport.isoPos().y + newP.y));
  var p2 = Coordinates.toIso(new Point(p.x+width, p.y));
  ctx.lineTo(Math.round(Viewport.isoPos().x + p2.x),Math.round(Viewport.isoPos().y + p2.y));
  var p3 = Coordinates.toIso(new Point(p.x+width, p.y+height));
  ctx.lineTo(Math.round(Viewport.isoPos().x + p3.x), Math.round(Viewport.isoPos().y + p3.y));
  var p4 = Coordinates.toIso(new Point(p.x, p.y+height));
  ctx.lineTo(Math.round(Viewport.isoPos().x + p4.x), Math.round(Viewport.isoPos().y + p4.y));
  ctx.closePath();
  ctx.fill();
}

var checkKeys = function () {
//  console.log(keysDown);
  if(79 in keysDown) {
    keyHeldDown++
    if(keyHeldDown === 1) {
      WorldConstants.debugOutput = !WorldConstants.debugOutput;
    }
  } else {
    keyHeldDown = 0;
  }
	if (38 in keysDown) { // Player holding up
    Viewport.pos.y+=5;
    Viewport.pos.x+=5;
	}
	else if (40 in keysDown) { // Player holding down
    Viewport.pos.y-=5;
    Viewport.pos.x-=5;
    
	}
	if (37 in keysDown) { // Player holding left
    Viewport.pos.x+=5;
    Viewport.pos.y-=5;
	}
	else if (39 in keysDown) { // Player holding right
    Viewport.pos.x-=5;
    Viewport.pos.y+=5;
	}

}

GameLoop();
</script>
</body>
</html>
